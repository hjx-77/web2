import{p as t,c as e,i as n,q as s,v as o,x as c,y as a,r,d as i,z as u,g as f,o as l,w as p,n as h,h as d,A as y}from"./chunk-BEtB-6HN.js";let b;const v=t=>b=t,_=Symbol();function j(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}var S,O;function $(){const t=u(!0),e=t.run(()=>r({}));let n=[],s=[];const o=y({install(t){v(o),o._a=t,t.provide(_,o),t.config.globalProperties.$pinia=o,s.forEach(t=>n.push(t)),s=[]},use(t){return this._a?n.push(t):s.push(t),this},_p:n,_a:null,_e:t,_s:new Map,state:e});return o}(O=S||(S={})).direct="direct",O.patchObject="patch object",O.patchFunction="patch function";const g=()=>{};function m(t,e,n,s=g){t.add(e);const o=()=>{t.delete(e)&&s()};return!n&&f()&&l(o),o}function w(t,...e){t.forEach(t=>{t(...e)})}const P=t=>t(),E=Symbol(),x=Symbol();function A(t,e){t instanceof Map&&e instanceof Map?e.forEach((e,n)=>t.set(n,e)):t instanceof Set&&e instanceof Set&&e.forEach(t.add,t);for(const o in e){if(!e.hasOwnProperty(o))continue;const c=e[o],a=t[o];j(a)&&j(c)&&t.hasOwnProperty(o)&&!n(c)&&!s(c)?t[o]=A(a,c):t[o]=c}return t}const I=Symbol();function M(t){return!j(t)||!Object.prototype.hasOwnProperty.call(t,I)}const{assign:k}=Object;function F(t){return!(!n(t)||!t.effect)}function q(e,o,c={},a,f,l){let d;const y=k({actions:{}},c),b={deep:!0};let _,j,O,$=new Set,I=new Set;const q=a.state.value[e];let z;function C(t){let n;_=j=!1,"function"==typeof t?(t(a.state.value[e]),n={type:S.patchFunction,storeId:e,events:O}):(A(a.state.value[e],t),n={type:S.patchObject,payload:t,storeId:e,events:O});const s=z=Symbol();h().then(()=>{z===s&&(_=!0)}),j=!0,w($,n,a.state.value[e])}l||q||(a.state.value[e]={}),r({});const J=l?function(){const{state:t}=c,e=t?t():{};this.$patch(t=>{k(t,e)})}:g;const N=(t,n="")=>{if(E in t)return t[x]=n,t;const s=function(){v(a);const n=Array.from(arguments),o=new Set,c=new Set;let r;w(I,{args:n,name:s[x],store:B,after:function(t){o.add(t)},onError:function(t){c.add(t)}});try{r=t.apply(this&&this.$id===e?this:B,n)}catch(i){throw w(c,i),i}return r instanceof Promise?r.then(t=>(w(o,t),t)).catch(t=>(w(c,t),Promise.reject(t))):(w(o,r),r)};return s[E]=!0,s[x]=n,s},W={_p:a,$id:e,$onAction:m.bind(null,I),$patch:C,$reset:J,$subscribe(t,n={}){const s=m($,t,n.detached,()=>o()),o=d.run(()=>p(()=>a.state.value[e],s=>{("sync"===n.flush?j:_)&&t({storeId:e,type:S.direct,events:O},s)},k({},b,n)));return s},$dispose:function(){d.stop(),$.clear(),I.clear(),a._s.delete(e)}},B=i(W);a._s.set(e,B);const D=(a._a&&a._a.runWithContext||P)(()=>a._e.run(()=>(d=u()).run(()=>o({action:N}))));for(const t in D){const o=D[t];if(n(o)&&!F(o)||s(o))l||(q&&M(o)&&(n(o)?o.value=q[t]:A(o,q[t])),a.state.value[e][t]=o);else if("function"==typeof o){const e=N(o,t);D[t]=e,y.actions[t]=o}}return k(B,D),k(t(B),D),Object.defineProperty(B,"$state",{get:()=>a.state.value[e],set:t=>{C(e=>{k(e,t)})}}),a._p.forEach(t=>{k(B,d.run(()=>t({store:B,app:a._a,pinia:a,options:y})))}),q&&l&&c.hydrate&&c.hydrate(B.$state,q),_=!0,j=!0,B}function z(t,n,s){let o;const r="function"==typeof n;function i(s,i){const u=a();(s=s||(u?c(_,null):null))&&v(s),(s=b)._s.has(t)||(r?q(t,n,o,s):function(t,n,s){const{state:o,actions:c,getters:a}=n,r=s.state.value[t];let i;i=q(t,function(){r||(s.state.value[t]=o?o():{});const n=d(s.state.value[t]);return k(n,c,Object.keys(a||{}).reduce((n,o)=>(n[o]=y(e(()=>{v(s);const e=s._s.get(t);return a[o].call(e,e)})),n),{}))},n,s,0,!0)}(t,o,s));return s._s.get(t)}return o=r?s:n,i.$id=t,i}function C(c){const a=t(c),r={};for(const t in a){const i=a[t];i.effect?r[t]=e({get:()=>c[t],set(e){c[t]=e}}):(n(i)||s(i))&&(r[t]=o(c,t))}return r}export{$ as c,z as d,C as s};
