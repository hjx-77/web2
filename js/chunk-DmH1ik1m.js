function e(e,n,t){function o(t,o){if(t._zod||Object.defineProperty(t,"_zod",{value:{def:o,constr:i,traits:new Set},enumerable:!1}),t._zod.traits.has(e))return;t._zod.traits.add(e),n(t,o);const r=i.prototype,s=Object.keys(r);for(let e=0;e<s.length;e++){const n=s[e];n in t||(t[n]=r[n].bind(t))}}const r=t?.Parent??Object;class s extends r{}function i(e){var n;const r=t?.Parent?new s:this;o(r,e),(n=r._zod).deferred??(n.deferred=[]);for(const t of r._zod.deferred)t();return r}return Object.defineProperty(s,"name",{value:e}),Object.defineProperty(i,"init",{value:o}),Object.defineProperty(i,Symbol.hasInstance,{value:n=>!!(t?.Parent&&n instanceof t.Parent)||n?._zod?.traits?.has(e)}),Object.defineProperty(i,"name",{value:e}),i}class n extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}class t extends Error{constructor(e){super(`Encountered unidirectional transform during encode: ${e}`),this.name="ZodEncodeError"}}const o={};function r(e){return o}function s(e){const n=Object.values(e).filter(e=>"number"==typeof e);return Object.entries(e).filter(([e,t])=>-1===n.indexOf(+e)).map(([e,n])=>n)}function i(e,n){return"bigint"==typeof n?n.toString():n}function a(e){return{get value(){{const n=e();return Object.defineProperty(this,"value",{value:n}),n}}}}function c(e){return null==e}function u(e){const n=e.startsWith("^")?1:0,t=e.endsWith("$")?e.length-1:e.length;return e.slice(n,t)}const d=Symbol("evaluating");function l(e,n,t){let o;Object.defineProperty(e,n,{get(){if(o!==d)return void 0===o&&(o=d,o=t()),o},set(t){Object.defineProperty(e,n,{value:t})},configurable:!0})}function p(e,n,t){Object.defineProperty(e,n,{value:t,writable:!0,enumerable:!0,configurable:!0})}function f(...e){const n={};for(const t of e){const e=Object.getOwnPropertyDescriptors(t);Object.assign(n,e)}return Object.defineProperties({},n)}function h(e){return JSON.stringify(e)}const m="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function y(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}const _=a(()=>{if("undefined"!=typeof navigator&&navigator?.userAgent?.includes("Cloudflare"))return!1;try{return new Function(""),!0}catch(e){return!1}});function v(e){if(!1===y(e))return!1;const n=e.constructor;if(void 0===n)return!0;if("function"!=typeof n)return!0;const t=n.prototype;return!1!==y(t)&&!1!==Object.prototype.hasOwnProperty.call(t,"isPrototypeOf")}function g(e){return v(e)?{...e}:Array.isArray(e)?[...e]:e}const z=new Set(["string","number","symbol"]);function b(e,n,t){const o=new e._zod.constr(n??e._zod.def);return n&&!t?.parent||(o._zod.parent=e),o}function w(e){const n=e;if(!n)return{};if("string"==typeof n)return{error:()=>n};if(void 0!==n?.message){if(void 0!==n?.error)throw new Error("Cannot specify both `message` and `error` params");n.error=n.message}return delete n.message,"string"==typeof n.error?{...n,error:()=>n.error}:n}const O={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-34028234663852886e22,34028234663852886e22],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]};function k(e,n=0){if(!0===e.aborted)return!0;for(let t=n;t<e.issues.length;t++)if(!0!==e.issues[t]?.continue)return!0;return!1}function N(e,n){return n.map(n=>{var t;return(t=n).path??(t.path=[]),n.path.unshift(e),n})}function S(e){return"string"==typeof e?e:e?.message}function T(e,n,t){const o={...e,path:e.path??[]};if(!e.message){const r=S(e.inst?._zod.def?.error?.(e))??S(n?.error?.(e))??S(t.customError?.(e))??S(t.localeError?.(e))??"Invalid input";o.message=r}return delete o.inst,delete o.continue,n?.reportInput||delete o.input,o}function $(e){return Array.isArray(e)?"array":"string"==typeof e?"string":"unknown"}function x(...e){const[n,t,o]=e;return"string"==typeof n?{message:n,code:"custom",input:t,inst:o}:{...n}}const E=(e,n)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:n,enumerable:!1}),e.message=JSON.stringify(n,i,2),Object.defineProperty(e,"toString",{value:()=>e.message,enumerable:!1})},P=e("$ZodError",E),j=e("$ZodError",E,{Parent:Error});const I=e=>(t,o,s,i)=>{const a=s?Object.assign(s,{async:!1}):{async:!1},c=t._zod.run({value:o,issues:[]},a);if(c instanceof Promise)throw new n;if(c.issues.length){const n=new(i?.Err??e)(c.issues.map(e=>T(e,a,r())));throw m(n,i?.callee),n}return c.value},Z=e=>async(n,t,o,s)=>{const i=o?Object.assign(o,{async:!0}):{async:!0};let a=n._zod.run({value:t,issues:[]},i);if(a instanceof Promise&&(a=await a),a.issues.length){const n=new(s?.Err??e)(a.issues.map(e=>T(e,i,r())));throw m(n,s?.callee),n}return a.value},J=e=>(t,o,s)=>{const i=s?{...s,async:!1}:{async:!1},a=t._zod.run({value:o,issues:[]},i);if(a instanceof Promise)throw new n;return a.issues.length?{success:!1,error:new(e??P)(a.issues.map(e=>T(e,i,r())))}:{success:!0,data:a.value}},A=J(j),M=e=>async(n,t,o)=>{const s=o?Object.assign(o,{async:!0}):{async:!0};let i=n._zod.run({value:t,issues:[]},s);return i instanceof Promise&&(i=await i),i.issues.length?{success:!1,error:new e(i.issues.map(e=>T(e,s,r())))}:{success:!0,data:i.value}},V=M(j),R=e=>(n,t,o)=>{const r=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return I(e)(n,t,r)},C=e=>(n,t,o)=>I(e)(n,t,o),F=e=>async(n,t,o)=>{const r=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return Z(e)(n,t,r)},U=e=>async(n,t,o)=>Z(e)(n,t,o),D=e=>(n,t,o)=>{const r=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return J(e)(n,t,r)},G=e=>(n,t,o)=>J(e)(n,t,o),Y=e=>async(n,t,o)=>{const r=o?Object.assign(o,{direction:"backward"}):{direction:"backward"};return M(e)(n,t,r)},L=e=>async(n,t,o)=>M(e)(n,t,o),q=/^-?\d+$/,K=/^-?\d+(?:\.\d+)?$/,W=e("$ZodCheck",(e,n)=>{var t;e._zod??(e._zod={}),e._zod.def=n,(t=e._zod).onattach??(t.onattach=[])}),X={number:"number",bigint:"bigint",object:"date"},B=e("$ZodCheckLessThan",(e,n)=>{W.init(e,n);const t=X[typeof n.value];e._zod.onattach.push(e=>{const t=e._zod.bag,o=(n.inclusive?t.maximum:t.exclusiveMaximum)??Number.POSITIVE_INFINITY;n.value<o&&(n.inclusive?t.maximum=n.value:t.exclusiveMaximum=n.value)}),e._zod.check=o=>{(n.inclusive?o.value<=n.value:o.value<n.value)||o.issues.push({origin:t,code:"too_big",maximum:"object"==typeof n.value?n.value.getTime():n.value,input:o.value,inclusive:n.inclusive,inst:e,continue:!n.abort})}}),H=e("$ZodCheckGreaterThan",(e,n)=>{W.init(e,n);const t=X[typeof n.value];e._zod.onattach.push(e=>{const t=e._zod.bag,o=(n.inclusive?t.minimum:t.exclusiveMinimum)??Number.NEGATIVE_INFINITY;n.value>o&&(n.inclusive?t.minimum=n.value:t.exclusiveMinimum=n.value)}),e._zod.check=o=>{(n.inclusive?o.value>=n.value:o.value>n.value)||o.issues.push({origin:t,code:"too_small",minimum:"object"==typeof n.value?n.value.getTime():n.value,input:o.value,inclusive:n.inclusive,inst:e,continue:!n.abort})}}),Q=e("$ZodCheckMultipleOf",(e,n)=>{W.init(e,n),e._zod.onattach.push(e=>{var t;(t=e._zod.bag).multipleOf??(t.multipleOf=n.value)}),e._zod.check=t=>{if(typeof t.value!=typeof n.value)throw new Error("Cannot mix number and bigint in multiple_of check.");("bigint"==typeof t.value?t.value%n.value===BigInt(0):0===function(e,n){const t=(e.toString().split(".")[1]||"").length,o=n.toString();let r=(o.split(".")[1]||"").length;if(0===r&&/\d?e-\d?/.test(o)){const e=o.match(/\d?e-(\d?)/);e?.[1]&&(r=Number.parseInt(e[1]))}const s=t>r?t:r;return Number.parseInt(e.toFixed(s).replace(".",""))%Number.parseInt(n.toFixed(s).replace(".",""))/10**s}(t.value,n.value))||t.issues.push({origin:typeof t.value,code:"not_multiple_of",divisor:n.value,input:t.value,inst:e,continue:!n.abort})}}),ee=e("$ZodCheckNumberFormat",(e,n)=>{W.init(e,n),n.format=n.format||"float64";const t=n.format?.includes("int"),o=t?"int":"number",[r,s]=O[n.format];e._zod.onattach.push(e=>{const o=e._zod.bag;o.format=n.format,o.minimum=r,o.maximum=s,t&&(o.pattern=q)}),e._zod.check=i=>{const a=i.value;if(t){if(!Number.isInteger(a))return void i.issues.push({expected:o,format:n.format,code:"invalid_type",continue:!1,input:a,inst:e});if(!Number.isSafeInteger(a))return void(a>0?i.issues.push({input:a,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,inclusive:!0,continue:!n.abort}):i.issues.push({input:a,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:o,inclusive:!0,continue:!n.abort}))}a<r&&i.issues.push({origin:"number",input:a,code:"too_small",minimum:r,inclusive:!0,inst:e,continue:!n.abort}),a>s&&i.issues.push({origin:"number",input:a,code:"too_big",maximum:s,inclusive:!0,inst:e,continue:!n.abort})}}),ne=e("$ZodCheckMaxLength",(e,n)=>{var t;W.init(e,n),(t=e._zod.def).when??(t.when=e=>{const n=e.value;return!c(n)&&void 0!==n.length}),e._zod.onattach.push(e=>{const t=e._zod.bag.maximum??Number.POSITIVE_INFINITY;n.maximum<t&&(e._zod.bag.maximum=n.maximum)}),e._zod.check=t=>{const o=t.value;if(o.length<=n.maximum)return;const r=$(o);t.issues.push({origin:r,code:"too_big",maximum:n.maximum,inclusive:!0,input:o,inst:e,continue:!n.abort})}}),te=e("$ZodCheckMinLength",(e,n)=>{var t;W.init(e,n),(t=e._zod.def).when??(t.when=e=>{const n=e.value;return!c(n)&&void 0!==n.length}),e._zod.onattach.push(e=>{const t=e._zod.bag.minimum??Number.NEGATIVE_INFINITY;n.minimum>t&&(e._zod.bag.minimum=n.minimum)}),e._zod.check=t=>{const o=t.value;if(o.length>=n.minimum)return;const r=$(o);t.issues.push({origin:r,code:"too_small",minimum:n.minimum,inclusive:!0,input:o,inst:e,continue:!n.abort})}}),oe=e("$ZodCheckLengthEquals",(e,n)=>{var t;W.init(e,n),(t=e._zod.def).when??(t.when=e=>{const n=e.value;return!c(n)&&void 0!==n.length}),e._zod.onattach.push(e=>{const t=e._zod.bag;t.minimum=n.length,t.maximum=n.length,t.length=n.length}),e._zod.check=t=>{const o=t.value,r=o.length;if(r===n.length)return;const s=$(o),i=r>n.length;t.issues.push({origin:s,...i?{code:"too_big",maximum:n.length}:{code:"too_small",minimum:n.length},inclusive:!0,exact:!0,input:t.value,inst:e,continue:!n.abort})}}),re=e("$ZodCheckOverwrite",(e,n)=>{W.init(e,n),e._zod.check=e=>{e.value=n.tx(e.value)}});class se{constructor(e=[]){this.content=[],this.indent=0,this&&(this.args=e)}indented(e){this.indent+=1,e(this),this.indent-=1}write(e){if("function"==typeof e)return e(this,{execution:"sync"}),void e(this,{execution:"async"});const n=e.split("\n").filter(e=>e),t=Math.min(...n.map(e=>e.length-e.trimStart().length)),o=n.map(e=>e.slice(t)).map(e=>" ".repeat(2*this.indent)+e);for(const r of o)this.content.push(r)}compile(){const e=Function,n=this?.args;return new e(...n,[...(this?.content??[""]).map(e=>`  ${e}`)].join("\n"))}}const ie={major:4,minor:3,patch:5},ae=e("$ZodType",(e,t)=>{var o;e??(e={}),e._zod.def=t,e._zod.bag=e._zod.bag||{},e._zod.version=ie;const r=[...e._zod.def.checks??[]];e._zod.traits.has("$ZodCheck")&&r.unshift(e);for(const n of r)for(const t of n._zod.onattach)t(e);if(0===r.length)(o=e._zod).deferred??(o.deferred=[]),e._zod.deferred?.push(()=>{e._zod.run=e._zod.parse});else{const t=(e,t,o)=>{let r,s=k(e);for(const i of t){if(i._zod.def.when){if(!i._zod.def.when(e))continue}else if(s)continue;const t=e.issues.length,a=i._zod.check(e);if(a instanceof Promise&&!1===o?.async)throw new n;if(r||a instanceof Promise)r=(r??Promise.resolve()).then(async()=>{await a;e.issues.length!==t&&(s||(s=k(e,t)))});else{if(e.issues.length===t)continue;s||(s=k(e,t))}}return r?r.then(()=>e):e},o=(o,s,i)=>{if(k(o))return o.aborted=!0,o;const a=t(s,r,i);if(a instanceof Promise){if(!1===i.async)throw new n;return a.then(n=>e._zod.parse(n,i))}return e._zod.parse(a,i)};e._zod.run=(s,i)=>{if(i.skipChecks)return e._zod.parse(s,i);if("backward"===i.direction){const n=e._zod.parse({value:s.value,issues:[]},{...i,skipChecks:!0});return n instanceof Promise?n.then(e=>o(e,s,i)):o(n,s,i)}const a=e._zod.parse(s,i);if(a instanceof Promise){if(!1===i.async)throw new n;return a.then(e=>t(e,r,i))}return t(a,r,i)}}l(e,"~standard",()=>({validate:n=>{try{const t=A(e,n);return t.success?{value:t.data}:{issues:t.error?.issues}}catch(t){return V(e,n).then(e=>e.success?{value:e.data}:{issues:e.error?.issues})}},vendor:"zod",version:1}))}),ce=e("$ZodNumber",(e,n)=>{ae.init(e,n),e._zod.pattern=e._zod.bag.pattern??K,e._zod.parse=(t,o)=>{if(n.coerce)try{t.value=Number(t.value)}catch(i){}const r=t.value;if("number"==typeof r&&!Number.isNaN(r)&&Number.isFinite(r))return t;const s="number"==typeof r?Number.isNaN(r)?"NaN":Number.isFinite(r)?void 0:"Infinity":void 0;return t.issues.push({expected:"number",code:"invalid_type",input:r,inst:e,...s?{received:s}:{}}),t}}),ue=e("$ZodNumberFormat",(e,n)=>{ee.init(e,n),ce.init(e,n)}),de=e("$ZodUnknown",(e,n)=>{ae.init(e,n),e._zod.parse=e=>e}),le=e("$ZodNever",(e,n)=>{ae.init(e,n),e._zod.parse=(n,t)=>(n.issues.push({expected:"never",code:"invalid_type",input:n.value,inst:e}),n)});function pe(e,n,t){e.issues.length&&n.issues.push(...N(t,e.issues)),n.value[t]=e.value}const fe=e("$ZodArray",(e,n)=>{ae.init(e,n),e._zod.parse=(t,o)=>{const r=t.value;if(!Array.isArray(r))return t.issues.push({expected:"array",code:"invalid_type",input:r,inst:e}),t;t.value=Array(r.length);const s=[];for(let e=0;e<r.length;e++){const i=r[e],a=n.element._zod.run({value:i,issues:[]},o);a instanceof Promise?s.push(a.then(n=>pe(n,t,e))):pe(a,t,e)}return s.length?Promise.all(s).then(()=>t):t}});function he(e,n,t,o,r){if(e.issues.length){if(r&&!(t in o))return;n.issues.push(...N(t,e.issues))}void 0===e.value?t in o&&(n.value[t]=void 0):n.value[t]=e.value}function me(e){const n=Object.keys(e.shape);for(const r of n)if(!e.shape?.[r]?._zod?.traits?.has("$ZodType"))throw new Error(`Invalid element at key "${r}": expected a Zod schema`);const t=(o=e.shape,Object.keys(o).filter(e=>"optional"===o[e]._zod.optin&&"optional"===o[e]._zod.optout));var o;return{...e,keys:n,keySet:new Set(n),numKeys:n.length,optionalKeys:new Set(t)}}function ye(e,n,t,o,r,s){const i=[],a=r.keySet,c=r.catchall._zod,u=c.def.type,d="optional"===c.optout;for(const l in n){if(a.has(l))continue;if("never"===u){i.push(l);continue}const r=c.run({value:n[l],issues:[]},o);r instanceof Promise?e.push(r.then(e=>he(e,t,l,n,d))):he(r,t,l,n,d)}return i.length&&t.issues.push({code:"unrecognized_keys",keys:i,input:n,inst:s}),e.length?Promise.all(e).then(()=>t):t}const _e=e("$ZodObject",(e,n)=>{ae.init(e,n);const t=Object.getOwnPropertyDescriptor(n,"shape");if(!t?.get){const e=n.shape;Object.defineProperty(n,"shape",{get:()=>{const t={...e};return Object.defineProperty(n,"shape",{value:t}),t}})}const o=a(()=>me(n));l(e._zod,"propValues",()=>{const e=n.shape,t={};for(const n in e){const o=e[n]._zod;if(o.values){t[n]??(t[n]=new Set);for(const e of o.values)t[n].add(e)}}return t});const r=y,s=n.catchall;let i;e._zod.parse=(n,t)=>{i??(i=o.value);const a=n.value;if(!r(a))return n.issues.push({expected:"object",code:"invalid_type",input:a,inst:e}),n;n.value={};const c=[],u=i.shape;for(const e of i.keys){const o=u[e],r="optional"===o._zod.optout,s=o._zod.run({value:a[e],issues:[]},t);s instanceof Promise?c.push(s.then(t=>he(t,n,e,a,r))):he(s,n,e,a,r)}return s?ye(c,a,n,t,o.value,e):c.length?Promise.all(c).then(()=>n):n}}),ve=e("$ZodObjectJIT",(e,n)=>{_e.init(e,n);const t=e._zod.parse,r=a(()=>me(n));let s;const i=y,c=!o.jitless,u=c&&_.value,d=n.catchall;let l;e._zod.parse=(o,a)=>{l??(l=r.value);const p=o.value;return i(p)?c&&u&&!1===a?.async&&!0!==a.jitless?(s||(s=(e=>{const n=new se(["shape","payload","ctx"]),t=r.value,o=e=>{const n=h(e);return`shape[${n}]._zod.run({ value: input[${n}], issues: [] }, ctx)`};n.write("const input = payload.value;");const s=Object.create(null);let i=0;for(const r of t.keys)s[r]="key_"+i++;n.write("const newResult = {};");for(const r of t.keys){const t=s[r],i=h(r),a=e[r],c="optional"===a?._zod?.optout;n.write(`const ${t} = ${o(r)};`),c?n.write(`\n        if (${t}.issues.length) {\n          if (${i} in input) {\n            payload.issues = payload.issues.concat(${t}.issues.map(iss => ({\n              ...iss,\n              path: iss.path ? [${i}, ...iss.path] : [${i}]\n            })));\n          }\n        }\n        \n        if (${t}.value === undefined) {\n          if (${i} in input) {\n            newResult[${i}] = undefined;\n          }\n        } else {\n          newResult[${i}] = ${t}.value;\n        }\n        \n      `):n.write(`\n        if (${t}.issues.length) {\n          payload.issues = payload.issues.concat(${t}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${i}, ...iss.path] : [${i}]\n          })));\n        }\n        \n        if (${t}.value === undefined) {\n          if (${i} in input) {\n            newResult[${i}] = undefined;\n          }\n        } else {\n          newResult[${i}] = ${t}.value;\n        }\n        \n      `)}n.write("payload.value = newResult;"),n.write("return payload;");const a=n.compile();return(n,t)=>a(e,n,t)})(n.shape)),o=s(o,a),d?ye([],p,o,a,l,e):o):t(o,a):(o.issues.push({expected:"object",code:"invalid_type",input:p,inst:e}),o)}});function ge(e,n,t,o){for(const r of e)if(0===r.issues.length)return n.value=r.value,n;const s=e.filter(e=>!k(e));return 1===s.length?(n.value=s[0].value,s[0]):(n.issues.push({code:"invalid_union",input:n.value,inst:t,errors:e.map(e=>e.issues.map(e=>T(e,o,r())))}),n)}const ze=e("$ZodUnion",(e,n)=>{ae.init(e,n),l(e._zod,"optin",()=>n.options.some(e=>"optional"===e._zod.optin)?"optional":void 0),l(e._zod,"optout",()=>n.options.some(e=>"optional"===e._zod.optout)?"optional":void 0),l(e._zod,"values",()=>{if(n.options.every(e=>e._zod.values))return new Set(n.options.flatMap(e=>Array.from(e._zod.values)))}),l(e._zod,"pattern",()=>{if(n.options.every(e=>e._zod.pattern)){const e=n.options.map(e=>e._zod.pattern);return new RegExp(`^(${e.map(e=>u(e.source)).join("|")})$`)}});const t=1===n.options.length,o=n.options[0]._zod.run;e._zod.parse=(r,s)=>{if(t)return o(r,s);let i=!1;const a=[];for(const e of n.options){const n=e._zod.run({value:r.value,issues:[]},s);if(n instanceof Promise)a.push(n),i=!0;else{if(0===n.issues.length)return n;a.push(n)}}return i?Promise.all(a).then(n=>ge(n,r,e,s)):ge(a,r,e,s)}}),be=e("$ZodIntersection",(e,n)=>{ae.init(e,n),e._zod.parse=(e,t)=>{const o=e.value,r=n.left._zod.run({value:o,issues:[]},t),s=n.right._zod.run({value:o,issues:[]},t);return r instanceof Promise||s instanceof Promise?Promise.all([r,s]).then(([n,t])=>Oe(e,n,t)):Oe(e,r,s)}});function we(e,n){if(e===n)return{valid:!0,data:e};if(e instanceof Date&&n instanceof Date&&+e===+n)return{valid:!0,data:e};if(v(e)&&v(n)){const t=Object.keys(n),o=Object.keys(e).filter(e=>-1!==t.indexOf(e)),r={...e,...n};for(const s of o){const t=we(e[s],n[s]);if(!t.valid)return{valid:!1,mergeErrorPath:[s,...t.mergeErrorPath]};r[s]=t.data}return{valid:!0,data:r}}if(Array.isArray(e)&&Array.isArray(n)){if(e.length!==n.length)return{valid:!1,mergeErrorPath:[]};const t=[];for(let o=0;o<e.length;o++){const r=we(e[o],n[o]);if(!r.valid)return{valid:!1,mergeErrorPath:[o,...r.mergeErrorPath]};t.push(r.data)}return{valid:!0,data:t}}return{valid:!1,mergeErrorPath:[]}}function Oe(e,n,t){const o=new Map;let r;for(const a of n.issues)if("unrecognized_keys"===a.code){r??(r=a);for(const e of a.keys)o.has(e)||o.set(e,{}),o.get(e).l=!0}else e.issues.push(a);for(const a of t.issues)if("unrecognized_keys"===a.code)for(const e of a.keys)o.has(e)||o.set(e,{}),o.get(e).r=!0;else e.issues.push(a);const s=[...o].filter(([,e])=>e.l&&e.r).map(([e])=>e);if(s.length&&r&&e.issues.push({...r,keys:s}),k(e))return e;const i=we(n.value,t.value);if(!i.valid)throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`);return e.value=i.data,e}const ke=e("$ZodEnum",(e,n)=>{ae.init(e,n);const t=s(n.entries),o=new Set(t);e._zod.values=o,e._zod.pattern=new RegExp(`^(${t.filter(e=>z.has(typeof e)).map(e=>"string"==typeof e?e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"):e.toString()).join("|")})$`),e._zod.parse=(n,r)=>{const s=n.value;return o.has(s)||n.issues.push({code:"invalid_value",values:t,input:s,inst:e}),n}}),Ne=e("$ZodTransform",(e,o)=>{ae.init(e,o),e._zod.parse=(r,s)=>{if("backward"===s.direction)throw new t(e.constructor.name);const i=o.transform(r.value,r);if(s.async){return(i instanceof Promise?i:Promise.resolve(i)).then(e=>(r.value=e,r))}if(i instanceof Promise)throw new n;return r.value=i,r}});function Se(e,n){return e.issues.length&&void 0===n?{issues:[],value:void 0}:e}const Te=e("$ZodOptional",(e,n)=>{ae.init(e,n),e._zod.optin="optional",e._zod.optout="optional",l(e._zod,"values",()=>n.innerType._zod.values?new Set([...n.innerType._zod.values,void 0]):void 0),l(e._zod,"pattern",()=>{const e=n.innerType._zod.pattern;return e?new RegExp(`^(${u(e.source)})?$`):void 0}),e._zod.parse=(e,t)=>{if("optional"===n.innerType._zod.optin){const o=n.innerType._zod.run(e,t);return o instanceof Promise?o.then(n=>Se(n,e.value)):Se(o,e.value)}return void 0===e.value?e:n.innerType._zod.run(e,t)}}),$e=e("$ZodExactOptional",(e,n)=>{Te.init(e,n),l(e._zod,"values",()=>n.innerType._zod.values),l(e._zod,"pattern",()=>n.innerType._zod.pattern),e._zod.parse=(e,t)=>n.innerType._zod.run(e,t)}),xe=e("$ZodNullable",(e,n)=>{ae.init(e,n),l(e._zod,"optin",()=>n.innerType._zod.optin),l(e._zod,"optout",()=>n.innerType._zod.optout),l(e._zod,"pattern",()=>{const e=n.innerType._zod.pattern;return e?new RegExp(`^(${u(e.source)}|null)$`):void 0}),l(e._zod,"values",()=>n.innerType._zod.values?new Set([...n.innerType._zod.values,null]):void 0),e._zod.parse=(e,t)=>null===e.value?e:n.innerType._zod.run(e,t)}),Ee=e("$ZodDefault",(e,n)=>{ae.init(e,n),e._zod.optin="optional",l(e._zod,"values",()=>n.innerType._zod.values),e._zod.parse=(e,t)=>{if("backward"===t.direction)return n.innerType._zod.run(e,t);if(void 0===e.value)return e.value=n.defaultValue,e;const o=n.innerType._zod.run(e,t);return o instanceof Promise?o.then(e=>Pe(e,n)):Pe(o,n)}});function Pe(e,n){return void 0===e.value&&(e.value=n.defaultValue),e}const je=e("$ZodPrefault",(e,n)=>{ae.init(e,n),e._zod.optin="optional",l(e._zod,"values",()=>n.innerType._zod.values),e._zod.parse=(e,t)=>("backward"===t.direction||void 0===e.value&&(e.value=n.defaultValue),n.innerType._zod.run(e,t))}),Ie=e("$ZodNonOptional",(e,n)=>{ae.init(e,n),l(e._zod,"values",()=>{const e=n.innerType._zod.values;return e?new Set([...e].filter(e=>void 0!==e)):void 0}),e._zod.parse=(t,o)=>{const r=n.innerType._zod.run(t,o);return r instanceof Promise?r.then(n=>Ze(n,e)):Ze(r,e)}});function Ze(e,n){return e.issues.length||void 0!==e.value||e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:n}),e}const Je=e("$ZodCatch",(e,n)=>{ae.init(e,n),l(e._zod,"optin",()=>n.innerType._zod.optin),l(e._zod,"optout",()=>n.innerType._zod.optout),l(e._zod,"values",()=>n.innerType._zod.values),e._zod.parse=(e,t)=>{if("backward"===t.direction)return n.innerType._zod.run(e,t);const o=n.innerType._zod.run(e,t);return o instanceof Promise?o.then(o=>(e.value=o.value,o.issues.length&&(e.value=n.catchValue({...e,error:{issues:o.issues.map(e=>T(e,t,r()))},input:e.value}),e.issues=[]),e)):(e.value=o.value,o.issues.length&&(e.value=n.catchValue({...e,error:{issues:o.issues.map(e=>T(e,t,r()))},input:e.value}),e.issues=[]),e)}}),Ae=e("$ZodPipe",(e,n)=>{ae.init(e,n),l(e._zod,"values",()=>n.in._zod.values),l(e._zod,"optin",()=>n.in._zod.optin),l(e._zod,"optout",()=>n.out._zod.optout),l(e._zod,"propValues",()=>n.in._zod.propValues),e._zod.parse=(e,t)=>{if("backward"===t.direction){const o=n.out._zod.run(e,t);return o instanceof Promise?o.then(e=>Me(e,n.in,t)):Me(o,n.in,t)}const o=n.in._zod.run(e,t);return o instanceof Promise?o.then(e=>Me(e,n.out,t)):Me(o,n.out,t)}});function Me(e,n,t){return e.issues.length?(e.aborted=!0,e):n._zod.run({value:e.value,issues:e.issues},t)}const Ve=e("$ZodReadonly",(e,n)=>{ae.init(e,n),l(e._zod,"propValues",()=>n.innerType._zod.propValues),l(e._zod,"values",()=>n.innerType._zod.values),l(e._zod,"optin",()=>n.innerType?._zod?.optin),l(e._zod,"optout",()=>n.innerType?._zod?.optout),e._zod.parse=(e,t)=>{if("backward"===t.direction)return n.innerType._zod.run(e,t);const o=n.innerType._zod.run(e,t);return o instanceof Promise?o.then(Re):Re(o)}});function Re(e){return e.value=Object.freeze(e.value),e}const Ce=e("$ZodCustom",(e,n)=>{W.init(e,n),ae.init(e,n),e._zod.parse=(e,n)=>e,e._zod.check=t=>{const o=t.value,r=n.fn(o);if(r instanceof Promise)return r.then(n=>Fe(n,t,o,e));Fe(r,t,o,e)}});function Fe(e,n,t,o){if(!e){const e={code:"custom",input:t,inst:o,path:[...o._zod.def.path??[]],continue:!o._zod.def.abort};o._zod.def.params&&(e.params=o._zod.def.params),n.issues.push(x(e))}}var Ue;class De{constructor(){this._map=new WeakMap,this._idmap=new Map}add(e,...n){const t=n[0];return this._map.set(e,t),t&&"object"==typeof t&&"id"in t&&this._idmap.set(t.id,e),this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(e){const n=this._map.get(e);return n&&"object"==typeof n&&"id"in n&&this._idmap.delete(n.id),this._map.delete(e),this}get(e){const n=e._zod.parent;if(n){const t={...this.get(n)??{}};delete t.id;const o={...t,...this._map.get(e)};return Object.keys(o).length?o:void 0}return this._map.get(e)}has(e){return this._map.has(e)}}(Ue=globalThis).__zod_globalRegistry??(Ue.__zod_globalRegistry=new De);const Ge=globalThis.__zod_globalRegistry;function Ye(e,n){return new e({type:"number",checks:[],...w(n)})}function Le(e,n){return new e({type:"number",check:"number_format",abort:!1,format:"safeint",...w(n)})}function qe(e){return new e({type:"unknown"})}function Ke(e,n){return new e({type:"never",...w(n)})}function We(e,n){return new B({check:"less_than",...w(n),value:e,inclusive:!1})}function Xe(e,n){return new B({check:"less_than",...w(n),value:e,inclusive:!0})}function Be(e,n){return new H({check:"greater_than",...w(n),value:e,inclusive:!1})}function He(e,n){return new H({check:"greater_than",...w(n),value:e,inclusive:!0})}function Qe(e,n){return new Q({check:"multiple_of",...w(n),value:e})}function en(e,n){return new ne({check:"max_length",...w(n),maximum:e})}function nn(e,n){return new te({check:"min_length",...w(n),minimum:e})}function tn(e,n){return new oe({check:"length_equals",...w(n),length:e})}function on(e){return new re({check:"overwrite",tx:e})}function rn(e,n,t){return new e({type:"array",element:n,...w(t)})}function sn(e,n,t){return new e({type:"custom",check:"custom",fn:n,...w(t)})}function an(e){const n=cn(t=>(t.addIssue=e=>{if("string"==typeof e)t.issues.push(x(e,t.value,n._zod.def));else{const o=e;o.fatal&&(o.continue=!1),o.code??(o.code="custom"),o.input??(o.input=t.value),o.inst??(o.inst=n),o.continue??(o.continue=!n._zod.def.abort),t.issues.push(x(o))}},e(t.value,t)));return n}function cn(e,n){const t=new W({check:"custom",...w(n)});return t._zod.check=e,t}function un(e){let n=e?.target??"draft-2020-12";return"draft-4"===n&&(n="draft-04"),"draft-7"===n&&(n="draft-07"),{processors:e.processors??{},metadataRegistry:e?.metadata??Ge,target:n,unrepresentable:e?.unrepresentable??"throw",override:e?.override??(()=>{}),io:e?.io??"output",counter:0,seen:new Map,cycles:e?.cycles??"ref",reused:e?.reused??"inline",external:e?.external??void 0}}function dn(e,n,t={path:[],schemaPath:[]}){var o;const r=e._zod.def,s=n.seen.get(e);if(s){s.count++;return t.schemaPath.includes(e)&&(s.cycle=t.path),s.schema}const i={schema:{},count:1,cycle:void 0,path:t.path};n.seen.set(e,i);const a=e._zod.toJSONSchema?.();if(a)i.schema=a;else{const o={...t,schemaPath:[...t.schemaPath,e],path:t.path};if(e._zod.processJSONSchema)e._zod.processJSONSchema(n,i.schema,o);else{const t=i.schema,s=n.processors[r.type];if(!s)throw new Error(`[toJSONSchema]: Non-representable type encountered: ${r.type}`);s(e,n,t,o)}const s=e._zod.parent;s&&(i.ref||(i.ref=s),dn(s,n,o),n.seen.get(s).isParent=!0)}const c=n.metadataRegistry.get(e);c&&Object.assign(i.schema,c),"input"===n.io&&fn(e)&&(delete i.schema.examples,delete i.schema.default),"input"===n.io&&i.schema._prefault&&((o=i.schema).default??(o.default=i.schema._prefault)),delete i.schema._prefault;return n.seen.get(e).schema}function ln(e,n){const t=e.seen.get(n);if(!t)throw new Error("Unprocessed schema. This is a bug in Zod.");const o=new Map;for(const s of e.seen.entries()){const n=e.metadataRegistry.get(s[0])?.id;if(n){const e=o.get(n);if(e&&e!==s[0])throw new Error(`Duplicate schema id "${n}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);o.set(n,s[0])}}const r=n=>{if(n[1].schema.$ref)return;const o=n[1],{ref:r,defId:s}=(n=>{const o="draft-2020-12"===e.target?"$defs":"definitions";if(e.external){const t=e.external.registry.get(n[0])?.id,r=e.external.uri??(e=>e);if(t)return{ref:r(t)};const s=n[1].defId??n[1].schema.id??"schema"+e.counter++;return n[1].defId=s,{defId:s,ref:`${r("__shared")}#/${o}/${s}`}}if(n[1]===t)return{ref:"#"};const r=`#/${o}/`,s=n[1].schema.id??"__schema"+e.counter++;return{defId:s,ref:r+s}})(n);o.def={...o.schema},s&&(o.defId=s);const i=o.schema;for(const e in i)delete i[e];i.$ref=r};if("throw"===e.cycles)for(const s of e.seen.entries()){const e=s[1];if(e.cycle)throw new Error(`Cycle detected: #/${e.cycle?.join("/")}/<root>\n\nSet the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`)}for(const s of e.seen.entries()){const t=s[1];if(n===s[0]){r(s);continue}if(e.external){const t=e.external.registry.get(s[0])?.id;if(n!==s[0]&&t){r(s);continue}}const o=e.metadataRegistry.get(s[0])?.id;o?r(s):(t.cycle||t.count>1&&"ref"===e.reused)&&r(s)}}function pn(e,n){const t=e.seen.get(n);if(!t)throw new Error("Unprocessed schema. This is a bug in Zod.");const o=n=>{const t=e.seen.get(n);if(null===t.ref)return;const r=t.def??t.schema,s={...r},i=t.ref;if(t.ref=null,i){o(i);const t=e.seen.get(i),a=t.schema;!a.$ref||"draft-07"!==e.target&&"draft-04"!==e.target&&"openapi-3.0"!==e.target?Object.assign(r,a):(r.allOf=r.allOf??[],r.allOf.push(a)),Object.assign(r,s);if(n._zod.parent===i)for(const e in r)"$ref"!==e&&"allOf"!==e&&(e in s||delete r[e]);if(a.$ref)for(const e in r)"$ref"!==e&&"allOf"!==e&&e in t.def&&JSON.stringify(r[e])===JSON.stringify(t.def[e])&&delete r[e]}const a=n._zod.parent;if(a&&a!==i){o(a);const n=e.seen.get(a);if(n?.schema.$ref&&(r.$ref=n.schema.$ref,n.def))for(const e in r)"$ref"!==e&&"allOf"!==e&&e in n.def&&JSON.stringify(r[e])===JSON.stringify(n.def[e])&&delete r[e]}e.override({zodSchema:n,jsonSchema:r,path:t.path??[]})};for(const a of[...e.seen.entries()].reverse())o(a[0]);const r={};if("draft-2020-12"===e.target?r.$schema="https://json-schema.org/draft/2020-12/schema":"draft-07"===e.target?r.$schema="http://json-schema.org/draft-07/schema#":"draft-04"===e.target?r.$schema="http://json-schema.org/draft-04/schema#":e.target,e.external?.uri){const t=e.external.registry.get(n)?.id;if(!t)throw new Error("Schema is missing an `id` property");r.$id=e.external.uri(t)}Object.assign(r,t.def??t.schema);const s=e.external?.defs??{};for(const a of e.seen.entries()){const e=a[1];e.def&&e.defId&&(s[e.defId]=e.def)}e.external||Object.keys(s).length>0&&("draft-2020-12"===e.target?r.$defs=s:r.definitions=s);try{const t=JSON.parse(JSON.stringify(r));return Object.defineProperty(t,"~standard",{value:{...n["~standard"],jsonSchema:{input:hn(n,"input",e.processors),output:hn(n,"output",e.processors)}},enumerable:!1,writable:!1}),t}catch(i){throw new Error("Error converting schema to JSON.")}}function fn(e,n){const t=n??{seen:new Set};if(t.seen.has(e))return!1;t.seen.add(e);const o=e._zod.def;if("transform"===o.type)return!0;if("array"===o.type)return fn(o.element,t);if("set"===o.type)return fn(o.valueType,t);if("lazy"===o.type)return fn(o.getter(),t);if("promise"===o.type||"optional"===o.type||"nonoptional"===o.type||"nullable"===o.type||"readonly"===o.type||"default"===o.type||"prefault"===o.type)return fn(o.innerType,t);if("intersection"===o.type)return fn(o.left,t)||fn(o.right,t);if("record"===o.type||"map"===o.type)return fn(o.keyType,t)||fn(o.valueType,t);if("pipe"===o.type)return fn(o.in,t)||fn(o.out,t);if("object"===o.type){for(const e in o.shape)if(fn(o.shape[e],t))return!0;return!1}if("union"===o.type){for(const e of o.options)if(fn(e,t))return!0;return!1}if("tuple"===o.type){for(const e of o.items)if(fn(e,t))return!0;return!(!o.rest||!fn(o.rest,t))}return!1}const hn=(e,n,t={})=>o=>{const{libraryOptions:r,target:s}=o??{},i=un({...r??{},target:s,io:n,processors:t});return dn(e,i),ln(i,e),pn(i,e)},mn=(e,n,t,o)=>{const r=e._zod.def;dn(r.innerType,n,o);n.seen.get(e).ref=r.innerType},yn=e("ZodError",(e,n)=>{P.init(e,n),e.name="ZodError",Object.defineProperties(e,{format:{value:n=>function(e,n=e=>e.message){const t={_errors:[]},o=e=>{for(const r of e.issues)if("invalid_union"===r.code&&r.errors.length)r.errors.map(e=>o({issues:e}));else if("invalid_key"===r.code)o({issues:r.issues});else if("invalid_element"===r.code)o({issues:r.issues});else if(0===r.path.length)t._errors.push(n(r));else{let e=t,o=0;for(;o<r.path.length;){const t=r.path[o];o===r.path.length-1?(e[t]=e[t]||{_errors:[]},e[t]._errors.push(n(r))):e[t]=e[t]||{_errors:[]},e=e[t],o++}}};return o(e),t}(e,n)},flatten:{value:n=>function(e,n=e=>e.message){const t={},o=[];for(const r of e.issues)r.path.length>0?(t[r.path[0]]=t[r.path[0]]||[],t[r.path[0]].push(n(r))):o.push(n(r));return{formErrors:o,fieldErrors:t}}(e,n)},addIssue:{value:n=>{e.issues.push(n),e.message=JSON.stringify(e.issues,i,2)}},addIssues:{value:n=>{e.issues.push(...n),e.message=JSON.stringify(e.issues,i,2)}},isEmpty:{get:()=>0===e.issues.length}})},{Parent:Error}),_n=I(yn),vn=Z(yn),gn=J(yn),zn=M(yn),bn=R(yn),wn=C(yn),On=F(yn),kn=U(yn),Nn=D(yn),Sn=G(yn),Tn=Y(yn),$n=L(yn),xn=e("ZodType",(e,n)=>(ae.init(e,n),Object.assign(e["~standard"],{jsonSchema:{input:hn(e,"input"),output:hn(e,"output")}}),e.toJSONSchema=((e,n={})=>t=>{const o=un({...t,processors:n});return dn(e,o),ln(o,e),pn(o,e)})(e,{}),e.def=n,e.type=n.type,Object.defineProperty(e,"_def",{value:n}),e.check=(...t)=>e.clone(f(n,{checks:[...n.checks??[],...t.map(e=>"function"==typeof e?{_zod:{check:e,def:{check:"custom"},onattach:[]}}:e)]}),{parent:!0}),e.with=e.check,e.clone=(n,t)=>b(e,n,t),e.brand=()=>e,e.register=(n,t)=>(n.add(e,t),e),e.parse=(n,t)=>_n(e,n,t,{callee:e.parse}),e.safeParse=(n,t)=>gn(e,n,t),e.parseAsync=async(n,t)=>vn(e,n,t,{callee:e.parseAsync}),e.safeParseAsync=async(n,t)=>zn(e,n,t),e.spa=e.safeParseAsync,e.encode=(n,t)=>bn(e,n,t),e.decode=(n,t)=>wn(e,n,t),e.encodeAsync=async(n,t)=>On(e,n,t),e.decodeAsync=async(n,t)=>kn(e,n,t),e.safeEncode=(n,t)=>Nn(e,n,t),e.safeDecode=(n,t)=>Sn(e,n,t),e.safeEncodeAsync=async(n,t)=>Tn(e,n,t),e.safeDecodeAsync=async(n,t)=>$n(e,n,t),e.refine=(n,t)=>e.check(function(e,n={}){return sn(tt,e,n)}(n,t)),e.superRefine=n=>e.check(an(n)),e.overwrite=n=>e.check(on(n)),e.optional=()=>Yn(e),e.exactOptional=()=>new Ln({type:"optional",innerType:e}),e.nullable=()=>Kn(e),e.nullish=()=>Yn(Kn(e)),e.nonoptional=n=>function(e,n){return new Bn({type:"nonoptional",innerType:e,...w(n)})}(e,n),e.array=()=>{return rn(Mn,e,n);var n},e.or=n=>{return new Cn({type:"union",options:[e,n],...w(t)});var t},e.and=n=>new Fn({type:"intersection",left:e,right:n}),e.transform=n=>et(e,new Dn({type:"transform",transform:n})),e.default=n=>{return t=n,new Wn({type:"default",innerType:e,get defaultValue(){return"function"==typeof t?t():g(t)}});var t},e.prefault=n=>{return t=n,new Xn({type:"prefault",innerType:e,get defaultValue(){return"function"==typeof t?t():g(t)}});var t},e.catch=n=>{return new Hn({type:"catch",innerType:e,catchValue:"function"==typeof(t=n)?t:()=>t});var t},e.pipe=n=>et(e,n),e.readonly=()=>new nt({type:"readonly",innerType:e}),e.describe=n=>{const t=e.clone();return Ge.add(t,{description:n}),t},Object.defineProperty(e,"description",{get:()=>Ge.get(e)?.description,configurable:!0}),e.meta=(...n)=>{if(0===n.length)return Ge.get(e);const t=e.clone();return Ge.add(t,n[0]),t},e.isOptional=()=>e.safeParse(void 0).success,e.isNullable=()=>e.safeParse(null).success,e.apply=n=>n(e),e)),En=e("ZodNumber",(e,n)=>{ce.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t)=>{const o=t,{minimum:r,maximum:s,format:i,multipleOf:a,exclusiveMaximum:c,exclusiveMinimum:u}=e._zod.bag;"string"==typeof i&&i.includes("int")?o.type="integer":o.type="number","number"==typeof u&&("draft-04"===n.target||"openapi-3.0"===n.target?(o.minimum=u,o.exclusiveMinimum=!0):o.exclusiveMinimum=u),"number"==typeof r&&(o.minimum=r,"number"==typeof u&&"draft-04"!==n.target&&(u>=r?delete o.minimum:delete o.exclusiveMinimum)),"number"==typeof c&&("draft-04"===n.target||"openapi-3.0"===n.target?(o.maximum=c,o.exclusiveMaximum=!0):o.exclusiveMaximum=c),"number"==typeof s&&(o.maximum=s,"number"==typeof c&&"draft-04"!==n.target&&(c<=s?delete o.maximum:delete o.exclusiveMaximum)),"number"==typeof a&&(o.multipleOf=a)})(e,n,t),e.gt=(n,t)=>e.check(Be(n,t)),e.gte=(n,t)=>e.check(He(n,t)),e.min=(n,t)=>e.check(He(n,t)),e.lt=(n,t)=>e.check(We(n,t)),e.lte=(n,t)=>e.check(Xe(n,t)),e.max=(n,t)=>e.check(Xe(n,t)),e.int=n=>e.check(In(n)),e.safe=n=>e.check(In(n)),e.positive=n=>e.check(Be(0,n)),e.nonnegative=n=>e.check(He(0,n)),e.negative=n=>e.check(We(0,n)),e.nonpositive=n=>e.check(Xe(0,n)),e.multipleOf=(n,t)=>e.check(Qe(n,t)),e.step=(n,t)=>e.check(Qe(n,t)),e.finite=()=>e;const t=e._zod.bag;e.minValue=Math.max(t.minimum??Number.NEGATIVE_INFINITY,t.exclusiveMinimum??Number.NEGATIVE_INFINITY)??null,e.maxValue=Math.min(t.maximum??Number.POSITIVE_INFINITY,t.exclusiveMaximum??Number.POSITIVE_INFINITY)??null,e.isInt=(t.format??"").includes("int")||Number.isSafeInteger(t.multipleOf??.5),e.isFinite=!0,e.format=t.format??null});function Pn(e){return Ye(En,e)}const jn=e("ZodNumberFormat",(e,n)=>{ue.init(e,n),En.init(e,n)});function In(e){return Le(jn,e)}const Zn=e("ZodUnknown",(e,n)=>{de.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(e,n,t)=>{}});function Jn(){return qe(Zn)}const An=e("ZodNever",(e,n)=>{le.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(e,n,t)=>((e,n,t)=>{t.not={}})(0,0,n)});const Mn=e("ZodArray",(e,n)=>{fe.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=t,s=e._zod.def,{minimum:i,maximum:a}=e._zod.bag;"number"==typeof i&&(r.minItems=i),"number"==typeof a&&(r.maxItems=a),r.type="array",r.items=dn(s.element,n,{...o,path:[...o.path,"items"]})})(e,n,t,o),e.element=n.element,e.min=(n,t)=>e.check(nn(n,t)),e.nonempty=n=>e.check(nn(1,n)),e.max=(n,t)=>e.check(en(n,t)),e.length=(n,t)=>e.check(tn(n,t)),e.unwrap=()=>e.element});const Vn=e("ZodObject",(e,n)=>{ve.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=t,s=e._zod.def;r.type="object",r.properties={};const i=s.shape;for(const u in i)r.properties[u]=dn(i[u],n,{...o,path:[...o.path,"properties",u]});const a=new Set(Object.keys(i)),c=new Set([...a].filter(e=>{const t=s.shape[e]._zod;return"input"===n.io?void 0===t.optin:void 0===t.optout}));c.size>0&&(r.required=Array.from(c)),"never"===s.catchall?._zod.def.type?r.additionalProperties=!1:s.catchall?s.catchall&&(r.additionalProperties=dn(s.catchall,n,{...o,path:[...o.path,"additionalProperties"]})):"output"===n.io&&(r.additionalProperties=!1)})(e,n,t,o),l(e,"shape",()=>n.shape),e.keyof=()=>function(e,n){const t=Array.isArray(e)?Object.fromEntries(e.map(e=>[e,e])):e;return new Un({type:"enum",entries:t,...w(n)})}(Object.keys(e._zod.def.shape)),e.catchall=n=>e.clone({...e._zod.def,catchall:n}),e.passthrough=()=>e.clone({...e._zod.def,catchall:Jn()}),e.loose=()=>e.clone({...e._zod.def,catchall:Jn()}),e.strict=()=>{return e.clone({...e._zod.def,catchall:Ke(An,n)});var n},e.strip=()=>e.clone({...e._zod.def,catchall:void 0}),e.extend=n=>function(e,n){if(!v(n))throw new Error("Invalid input to extend: expected a plain object");const t=e._zod.def.checks;if(t&&t.length>0){const t=e._zod.def.shape;for(const e in n)if(void 0!==Object.getOwnPropertyDescriptor(t,e))throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.")}const o=f(e._zod.def,{get shape(){const t={...e._zod.def.shape,...n};return p(this,"shape",t),t}});return b(e,o)}(e,n),e.safeExtend=n=>function(e,n){if(!v(n))throw new Error("Invalid input to safeExtend: expected a plain object");const t=f(e._zod.def,{get shape(){const t={...e._zod.def.shape,...n};return p(this,"shape",t),t}});return b(e,t)}(e,n),e.merge=n=>function(e,n){const t=f(e._zod.def,{get shape(){const t={...e._zod.def.shape,...n._zod.def.shape};return p(this,"shape",t),t},get catchall(){return n._zod.def.catchall},checks:[]});return b(e,t)}(e,n),e.pick=n=>function(e,n){const t=e._zod.def,o=t.checks;if(o&&o.length>0)throw new Error(".pick() cannot be used on object schemas containing refinements");return b(e,f(e._zod.def,{get shape(){const e={};for(const o in n){if(!(o in t.shape))throw new Error(`Unrecognized key: "${o}"`);n[o]&&(e[o]=t.shape[o])}return p(this,"shape",e),e},checks:[]}))}(e,n),e.omit=n=>function(e,n){const t=e._zod.def,o=t.checks;if(o&&o.length>0)throw new Error(".omit() cannot be used on object schemas containing refinements");const r=f(e._zod.def,{get shape(){const o={...e._zod.def.shape};for(const e in n){if(!(e in t.shape))throw new Error(`Unrecognized key: "${e}"`);n[e]&&delete o[e]}return p(this,"shape",o),o},checks:[]});return b(e,r)}(e,n),e.partial=(...n)=>function(e,n,t){const o=n._zod.def.checks;if(o&&o.length>0)throw new Error(".partial() cannot be used on object schemas containing refinements");const r=f(n._zod.def,{get shape(){const o=n._zod.def.shape,r={...o};if(t)for(const n in t){if(!(n in o))throw new Error(`Unrecognized key: "${n}"`);t[n]&&(r[n]=e?new e({type:"optional",innerType:o[n]}):o[n])}else for(const n in o)r[n]=e?new e({type:"optional",innerType:o[n]}):o[n];return p(this,"shape",r),r},checks:[]});return b(n,r)}(Gn,e,n[0]),e.required=(...n)=>function(e,n,t){const o=f(n._zod.def,{get shape(){const o=n._zod.def.shape,r={...o};if(t)for(const n in t){if(!(n in r))throw new Error(`Unrecognized key: "${n}"`);t[n]&&(r[n]=new e({type:"nonoptional",innerType:o[n]}))}else for(const n in o)r[n]=new e({type:"nonoptional",innerType:o[n]});return p(this,"shape",r),r}});return b(n,o)}(Bn,e,n[0])});function Rn(e,n){const t={type:"object",shape:e??{},...w(n)};return new Vn(t)}const Cn=e("ZodUnion",(e,n)=>{ze.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def,s=!1===r.inclusive,i=r.options.map((e,t)=>dn(e,n,{...o,path:[...o.path,s?"oneOf":"anyOf",t]}));s?t.oneOf=i:t.anyOf=i})(e,n,t,o),e.options=n.options});const Fn=e("ZodIntersection",(e,n)=>{be.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def,s=dn(r.left,n,{...o,path:[...o.path,"allOf",0]}),i=dn(r.right,n,{...o,path:[...o.path,"allOf",1]}),a=e=>"allOf"in e&&1===Object.keys(e).length,c=[...a(s)?s.allOf:[s],...a(i)?i.allOf:[i]];t.allOf=c})(e,n,t,o)});const Un=e("ZodEnum",(e,n)=>{ke.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t)=>{const o=s(e._zod.def.entries);o.every(e=>"number"==typeof e)&&(t.type="number"),o.every(e=>"string"==typeof e)&&(t.type="string"),t.enum=o})(e,0,t),e.enum=n.entries,e.options=Object.values(n.entries);const t=new Set(Object.keys(n.entries));e.extract=(e,o)=>{const r={};for(const s of e){if(!t.has(s))throw new Error(`Key ${s} not found in enum`);r[s]=n.entries[s]}return new Un({...n,checks:[],...w(o),entries:r})},e.exclude=(e,o)=>{const r={...n.entries};for(const n of e){if(!t.has(n))throw new Error(`Key ${n} not found in enum`);delete r[n]}return new Un({...n,checks:[],...w(o),entries:r})}});const Dn=e("ZodTransform",(e,n)=>{Ne.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(e,n,t)=>((e,n)=>{if("throw"===n.unrepresentable)throw new Error("Transforms cannot be represented in JSON Schema")})(0,e),e._zod.parse=(o,r)=>{if("backward"===r.direction)throw new t(e.constructor.name);o.addIssue=t=>{if("string"==typeof t)o.issues.push(x(t,o.value,n));else{const n=t;n.fatal&&(n.continue=!1),n.code??(n.code="custom"),n.input??(n.input=o.value),n.inst??(n.inst=e),o.issues.push(x(n))}};const s=n.transform(o.value,o);return s instanceof Promise?s.then(e=>(o.value=e,o)):(o.value=s,o)}});const Gn=e("ZodOptional",(e,n)=>{Te.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>mn(e,n,0,o),e.unwrap=()=>e._zod.def.innerType});function Yn(e){return new Gn({type:"optional",innerType:e})}const Ln=e("ZodExactOptional",(e,n)=>{$e.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>mn(e,n,0,o),e.unwrap=()=>e._zod.def.innerType});const qn=e("ZodNullable",(e,n)=>{xe.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def,s=dn(r.innerType,n,o),i=n.seen.get(e);"openapi-3.0"===n.target?(i.ref=r.innerType,t.nullable=!0):t.anyOf=[s,{type:"null"}]})(e,n,t,o),e.unwrap=()=>e._zod.def.innerType});function Kn(e){return new qn({type:"nullable",innerType:e})}const Wn=e("ZodDefault",(e,n)=>{Ee.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def;dn(r.innerType,n,o),n.seen.get(e).ref=r.innerType,t.default=JSON.parse(JSON.stringify(r.defaultValue))})(e,n,t,o),e.unwrap=()=>e._zod.def.innerType,e.removeDefault=e.unwrap});const Xn=e("ZodPrefault",(e,n)=>{je.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def;dn(r.innerType,n,o),n.seen.get(e).ref=r.innerType,"input"===n.io&&(t._prefault=JSON.parse(JSON.stringify(r.defaultValue)))})(e,n,t,o),e.unwrap=()=>e._zod.def.innerType});const Bn=e("ZodNonOptional",(e,n)=>{Ie.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def;dn(r.innerType,n,o),n.seen.get(e).ref=r.innerType})(e,n,0,o),e.unwrap=()=>e._zod.def.innerType});const Hn=e("ZodCatch",(e,n)=>{Je.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def;let s;dn(r.innerType,n,o),n.seen.get(e).ref=r.innerType;try{s=r.catchValue(void 0)}catch{throw new Error("Dynamic catch values are not supported in JSON Schema")}t.default=s})(e,n,t,o),e.unwrap=()=>e._zod.def.innerType,e.removeCatch=e.unwrap});const Qn=e("ZodPipe",(e,n)=>{Ae.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def,s="input"===n.io?"transform"===r.in._zod.def.type?r.out:r.in:r.out;dn(s,n,o),n.seen.get(e).ref=s})(e,n,0,o),e.in=n.in,e.out=n.out});function et(e,n){return new Qn({type:"pipe",in:e,out:n})}const nt=e("ZodReadonly",(e,n)=>{Ve.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(n,t,o)=>((e,n,t,o)=>{const r=e._zod.def;dn(r.innerType,n,o),n.seen.get(e).ref=r.innerType,t.readOnly=!0})(e,n,t,o),e.unwrap=()=>e._zod.def.innerType});const tt=e("ZodCustom",(e,n)=>{Ce.init(e,n),xn.init(e,n),e._zod.processJSONSchema=(e,n,t)=>((e,n)=>{if("throw"===n.unrepresentable)throw new Error("Custom types cannot be represented in JSON Schema")})(0,e)});export{Pn as n,Rn as o};
